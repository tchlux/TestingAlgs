     ! Fill the quadratics that are available for this location.
     IF (FIXING(I)) THEN
        ! If the right quadratic was computed before, reuse it.
        IF (AS(3) .NE. MAX_REAL) THEN
           AS(1) = AS(3) ; BS(1) = BS(3)
        ELSE
           ! Interpolate zero slope at I and point at I-1.
           AS(1) = (Y(I-1) - Y(I)) / (X(I-1) - X(I))**2
           BS(1) = - 2 * X(I) * AS(1)
        END IF
        ! Interpolate zero slope at I and point at I+1.
        AS(2) = (Y(I+1) - Y(I)) / (X(I+1) - X(I))**2
        BS(2) = - 2 * X(I) * AS(2)        
        ! Disable the "rightmost" quadratic.
        AS(3) = MAX_REAL ; BS(3) = 0.0_R8
     ELSE
        IF (MODIFIED(I) .AND. (I .LT. Z) .AND. (.NOT. (MODIFIED(I+1) .OR. FIXING(I+1)))) THEN
           ! Interpolate zero slope at I and point at I+1.
           AS(2) = MAX_REAL ; BS(2) = 0.0_R8
           AS(3) = (Y(I+1) - Y(I)) / (X(I+1) - X(I))**2
           BS(3) = - 2 * X(I) * AS(3)
        END IF
        ! Slide existing values left.
        AS(1) = AS(2) ; BS(1) = BS(2)
        AS(2) = AS(3) ; BS(2) = BS(3)
        IF ((I .LT. Z) .AND. FIXING(I+1)) THEN
           ! Interpolate zero slope at I+1 and point at I.
           AS(3) = (Y(I) - Y(I+1)) / (X(I) - X(I+1))**2
           BS(3) = - 2 * X(I+1) * AS(3)
        ELSE IF (I+1 .LT. Z) THEN ; CALL QUADRATIC(I+1, AS(3), BS(3))
        ELSE ; AS(3) = MAX_REAL ; BS(3) = 0.0_R8
        END IF
     END IF


exit()

# # Get the knots and values for the test.
# knots, values = TESTS[sorted(TESTS)[-1]]
# knots = np.asfortranarray(knots, dtype=float)
# values = np.asfortranarray(values, dtype=float)
# num_knots = len(knots)

print()
print(f"knots ({len(knots)}):\n  {str(knots[:3])[:-1]} ... {str(knots[-3:])[1:]}")
print()
print(f"values ({len(values)}):\n  {str(values[:3])[:-1]} ... {str(values[-3:])[1:]}")
print()

# Compute the spline knots and spline coefficients.
t.start()
sk, sc, info = splines.pmqsi(knots, values)
t.stop()
print("info: ",info)
print(f"Fortran time: {t()}s")
print()

# Construct the PCHIP approximation.
t.start()
f = PchipInterpolator(knots, values)
t.stop()
print(f"PCHIP time: {t()}s")
print()



# # --------------------------------------------------------
# from search_monotone import monotone_quintic_spline
# t.start()
# truth = monotone_quintic_spline(knots, values, exact=True)
# t.stop() ; print(f"Python time: {t()}s")
# # --------------------------------------------------------

# g = lambda x: splines.eval_spline(sk, sc, np.array([x], order='f', dtype=float), d=0)[0]
# p = Plot()
# p.add_func("PCHIP", f, [min(knots), knots[:10][-1]])
# p.add_func("PMQSI", g, [min(knots), knots[:10][-1]])
# p.show()

# # Make a pretty picture of the B-spline and its derivatives.
# padding = 0 #.1
# x = [knots[0]]
# for i in range(len(knots) -1):
#     x += list(np.linspace(knots[i], knots[i+1], 10))[1:]
# x = np.array(x, dtype=float)
# y, info = splines.eval_spline(sk, sc, x.copy(), d=0)
# print("y: ",y)
# p = Plot("Polynomial Interpolant")
# p.add("Spline", x, y, mode="lines", color=p.color(1))
# true_y = list(map(truth, x))
# p.add("Truth", x, true_y, mode="lines", color=p.color(1), dash="dot",fill="toprevy")
# p.add("Knots", knots, values, color=p.color(1))
# p.show(file_name=f"spline_test-N{len(values)}-C{len(values)}.html")



# p = Plot()
# test_name = "watson_test"
# N = 18
# x = np.linspace(0, 1, N)
# # Evaluate the "y" values at all points.
# y = np.asfortranarray( TESTS[test_name](x), dtype=float )
# p.add("Truth", x, y, mode="markers+lines")
# # Fit the PMQSI.
# t.start() ; sk, sc, info = splines.pmqsi(x, y) ; t.stop()
# pmqsi_fit = t.total
# # Eval the PMQSI.
# eval_pts = np.asfortranarray( np.linspace(0, 1, trials), dtype=float )
# t.start() ; splines.eval_spline(sk, sc, eval_pts, d=0) ; t.stop()
# pmqsi_eval = t.total / trials
# # Fit the PCHIP.
# t.start() ; f = PchipInterpolator(x, y) ; t.stop()
# pchip_fit = t.total
# # Eval the PCHIP.
# eval_pts = np.asfortranarray( np.linspace(0, 1, trials), dtype=float )
# t.start() ; f(eval_pts) ; t.stop()
# pchip_eval = t.total / trials


# p.add("PMQSI", np.linspace(0, 1, 1000),
#       splines.eval_spline(sk, sc, np.linspace(0, 1, 1000), d=0)[0], 
#       mode="lines")
# p.add_func("PCHIP", f, [0, 1])
# p.show()
# exit()


