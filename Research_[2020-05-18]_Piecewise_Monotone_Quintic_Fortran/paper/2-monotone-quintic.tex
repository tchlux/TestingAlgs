
\heading{2. MONOTONE QUINTIC INTERPOLATION}

In order to construct a monotone quintic interpolating spline, two
primary problems must be solved. First, reasonable derivative values
at data points need to be estimated. Second, the estimated derivative
values need to be modified to enforce monotonicity on all polynomial
pieces.

% The remainder of this section outlines three algorithms for
% constructing a quintic spline interpolant.  Algorithm 1 uses a
% quadratic facet model to construct initial first and second
% derivative estimates for the interpolating spline, Algorithm 2
% checks monotonicity of an interval, and Algorithm 3 defines a
% procedure for stepping initial first and second derivative estimates
% towards values which result in a monotone quintic spline.

Fritsch and Carlson [1980] originally proposed the use of central differences
to estimate derivatives, however this often leads to extra and unnecessary
{\it wiggles} in the spline when used to approximate second derivatives.
In an attempt to capture the local shape of the data, this package uses a
facet model from image processing [Haralick and Watson 1981] to estimate
first and second derivatives at breakpoints. Rather than picking a local
linear or quadratic fit with minimal residual, this work uses a quadratic
facet model that selects the local quadratic interpolant with minimum
magnitude curvature.

%% ===================================================================
%%                   Algorithm 1: QUADRATIC_FACET
\vskip 5mm
{\parindent 0mm
{\bf Algorithm 1:} {
\tt QUADRATIC\_FACET}$\bigl(X(1{:}n)$, $Y(1{:}n)$, $i \bigr)$

where $X_j$, $Y_j$ $\in \bbb{R}$ for $j = 1$, $\ldots$, $n$, and $1 < i
< n$. Returns the slope and curvature at $X_i$ of the local quadratic
interpolant with minimum magnitude curvature.

}
{\parindent=3mm
%% -------------------------------------------------------------------
\item{} {\tt if} $\bigl((Y_i \approx Y_{i-1})$ {\tt or} $(Y_i \approx
  Y_{i+1})\bigr)$ {\tt then; return $(0,0)$}
\item{} {\tt else if} $\bigl((Y_{i+1} - Y_i)(Y_i - Y_{i-1}) < 0\bigr)$
{\tt then}
\itemitem{} The point $(X_i$, $Y_i)$ is an extreme point. The
quadratic with minimum magnitude
curvature that has slope zero at $X_i$ will be the facet chosen.
\itemitem{} $f_1\:\hbox{interpolant to }(X_{i-1},Y_{i-1})$, $(X_i,Y_i)$,
  and $Df_1(X_i) = 0$.
\itemitem{} $f_2\:\hbox{interpolant to }(X_i,Y_i)$, $(X_{i+1},Y_{i+1})$,
  and $Df_2(X_i) = 0$.
\itemitem{} {\tt if} $\bigl(|D^2f_1| \leq |D^2f_2|\bigr)$ {\tt then;
  return} $\bigl(Df_1$, $D^2f_1\bigr)$
\itemitem{} {\tt else;} \hskip 34.25mm {\tt return} $\bigl(Df_2$,
$D^2f_2\bigr)$
\itemitem{} {\tt endif}
\item{} {\tt else}
\itemitem{} {The point $(X_i$, $Y_i)$ is in a monotone segment of
data. In the following, it is possible that either $f_1$ or $f_3$ does
not exist because $i = 2$ or $i = n-1$. In those cases, the minimum
magnitude curvature among existing quadratics is chosen.}
\itemitem{} $f_1\:\hbox{interpolant to }(X_{i-2},Y_{i-2})$,
  $(X_{i-1},Y_{i-1})$, and $(X_i,Y_i)$.
\itemitem{} $f_2\:\hbox{interpolant to }(X_{i-1},Y_{i-1})$,
  $(X_i,Y_i)$, and $(X_{i+1},Y_{i+1})$.
\itemitem{} $f_3\:\hbox{interpolant to }(X_i,Y_i)$,
  $(X_{i+1},Y_{i+1})$, and $(X_{i+2},Y_{i+2})$.
\itemitem{} {\tt if} \hskip 9mm $\bigl(|D^2f_1| = \min\bigl\{ |D^2f_1|,
 |D^2f_2|, |D^2f_3|\bigr\} \bigr)$ {\tt then; return}
 $\bigl(Df_1$, $D^2f_1\bigr)$
\itemitem{} {\tt else if} $\bigl(|D^2f_2| = \min\bigl\{ |D^2f_1|,
 |D^2f_2|, |D^2f_3|\bigr\} \bigr)$ {\tt then; return}
 $\bigl(Df_2$, $D^2f_2\bigr)$
\itemitem{} {\tt else;} \codent {\tt return} $\bigl(Df_3$, $D^2f_3\bigr)$
\item{} \codent {\tt endif}
\item{} {\tt endif}
}
\vskip 5mm
%% ----------------------------------------------------------------------

The estimated derivative values by the quadratic facet model are not
guaranteed to produce monotone quintic polynomial segments. Ulrich and
Watson [1994] established tight constraints on the monotonicity of a
quintic polynomial piece, while deferring to He{\ss} and Schmidt
[1994] for a relevant simplified case. The following algorithm
implements a sharp check for monotonicity by considering the
nondecreasing case. The nonincreasing case is handled similarly.

%% ===================================================================
%%                    Algorithm 2: IS_MONOTONE
\vskip 5mm
{\parindent 0mm
{\bf Algorithm 2:} {\tt IS\_MONOTONE}$\bigl(x_0, x_1, f \bigr)$

where $x_0$, $x_1 \in {\bbb R}$, $x_0 < x_1$, and $f$ is an order six
polynomial defined by $f(x_0)$, $Df(x_0)$, $D^2f(x_0)$, $f(x_1)$,
$Df(x_1)$, $D^2f(x_1)$. Returns {\tt TRUE} if $f$ is monotone
increasing on $[x_0,x_1]$.

}
{\parindent=6mm
%% -------------------------------------------------------------------
\item{1.} {\tt if} $\bigl(f(x_0) \approx f(x_1)\bigr)$ {\tt then}
\item{2.} \codent {\tt return} $\bigl( 0 = Df(x_0) = Df(x_1)
  = D^2f(x_0) = D^2f(x_1) \bigr)$
\item{3.} {\tt endif}
\item{4.} {\tt if} $\bigl(Df(x_0) < 0$ {\tt or} $Df(x_1) < 0\bigr)$ {\tt
  then; return FALSE; endif}
\item{5.} $w := x_1 - x_0$
\item{6.} $v := f(x_1) - f(x_0)$

\item{} {The necessity of Steps 2 and 4 follows directly from
  the fact that $f$ is $C^2$. The following Steps 7--13 coincide with
  a simplified condition for quintic monotonicity that reduces to one
  of cubic positivity studied by Schmidt and He{\ss} [1988]. Given
  $\alpha$, $\beta$, $\gamma$, and $\delta$ as defined by Schmidt and
  He{\ss}, monotonicity results when $\alpha \geq 0$, $\delta \geq 0$,
  $\beta \geq \alpha - 2 \sqrt{\alpha \delta}$, and $\gamma \geq
  \delta - 2 \sqrt{\alpha \delta}$.  Step 4 checked for $\delta < 0$,
  Step 8 checks $\alpha < 0$, Step 10 checks $\beta < \alpha - 2
  \sqrt{\alpha \delta}$, and Step 11 checks $\gamma < \delta - 2
  \sqrt{\alpha \delta}$. If none of the monotonicity conditions are
  violated, then the order six piece is monotone and Step 12
  concludes.}

\item{7.} {\tt if} $\bigl(Df(x_0) \approx 0$ {\tt or} $Df(x_1) \approx
0\bigr)$ {\tt then}
\item{8.} \codent {\tt if} $\bigl(D^2f(x_1)w > 4Df(x_1)$ {\tt then;
return FALSE; endif}
\item{9.} \codent $t := 2 \sqrt{Df(x_0) (4Df(x_1) - D^2f(x_1) w) }$
\item{10.} \codent {\tt if} $\bigl(t + 3Df(x_0) + D^2f(x_0)w < 0 \bigr)$
  {\tt then; return FALSE; endif}
\item{11.} \codent {\tt if} $\bigl(60v - w\bigl(24Df(x_0) + 32Df(x_1) - 2t
  + w(3D^2f(x_0) - 5D^2f(x_1))\bigr) < 0\bigr)$
\item{}   \codent \codent {\tt then; return FALSE; endif}
\item{12.} \codent {\tt return TRUE}
\item{13.} {\tt endif}

\item{} {The following code considers the full quintic monotonicity
case studied by Ulrich and Watson [1994]. Given $\tau_1$, $\alpha$,
$\beta$, and $\gamma$ as defined by Ulrich and Watson, a quintic
piece is proven to be monotone if and only if
$\tau_1 > 0$, and $\alpha, \gamma > -(\beta+2)/2$ when $\beta \leq 6$,
and $\alpha, \gamma > -2 \sqrt{\beta-2}$ when $\beta > 6$.
Step 14 checks $\tau_1 \le 0$, Steps 19 and 20 determine monotonicity based
on $\alpha$, $\beta$, and $\gamma$.}

\item{14.} {\tt if} $\bigl( w\bigl(2\sqrt{Df(x_0)\,Df(x_1)} - 3(Df(x_0) +
  Df(x_1))\bigr) - 24v \leq 0 \bigr)$
\item{} \codent {\tt then; return FALSE; endif}
\item{15.} $t := \bigl(Df(x_0)\, Df(x_1)\bigr)^{3/4}$
\item{16.} $\alpha := (4 Df(x_1) - D^2f(x_1)w) \sqrt{Df(x_0)} / t$
\item{17.} $\gamma := (4 Df(x_0) - D^2f(x_0)w) \sqrt{Df(x_1)} / t$
\item{18.} $\displaystyle \beta := {60v/w + 3\bigl(w(D^2f(x_1) -
  D^2f(x_0)) - 8(Df(x_0) + Df(x_1))\bigr) \over 2 \sqrt{Df(x_0)\,Df(x_1)}}$
\item{19.} {\tt if} $(\beta \leq 6)$ {\tt then; return}
$\bigl( \min\{\alpha,\gamma\} > - (\beta + 2) / 2 \bigr)$
\item{20.} {\tt else;} \hskip 18mm {\tt return}
$\bigl( \min\{\alpha,\gamma\} > -2 \sqrt{\beta - 2}\,\bigr)$
\item{21.} {\tt endif}
}
\vskip 5mm
%% ----------------------------------------------------------------------

It is shown by Ulrich and Watson [1994] that when $0 = DQ(X_i) =
DQ(X_{i+1}) = D^2Q(X_i) = D^2Q(X_{i+1})$, the quintic polynomial
over $[X_i$, $X_{i+1}]$ is guaranteed to be monotone. Using this fact, the
following algorithm shrinks (in magnitude) initial derivative estimates
until a monotone spline is achieved and outlines the core routine in the
accompanying package.

%% ===================================================================
%%       Algorithm 3: MQSI - Monotone quintic spline interpolant
\vskip 5mm
{\parindent 0mm
{\bf Algorithm 3:} {\tt MQSI}$\bigl(X(1{:}n), Y(1{:}n) \bigr)$

where $(X_i,Y_i) \in \bbb{R}\times\bbb{R}$, $i = 1$, $\ldots$, $n$ are data
points. Returns monotone quintic spline interpolant $Q(x)$ such that
$Q(X_i) = Y_i$ and is monotone increasing (decreasing) on all
intervals that $Y_i$ is monotone increasing (decreasing).

}
{\parindent=6mm
\item{} Approximate first and second derivatives at all $X_i$ with
{\tt QUADRATIC\_FACET}.
\item{} {\tt do} $i = 1, \ldots n-1$
\item{} \codent $\bigl(D Q(X_i)$, $D^2 Q(X_i)\bigr):=$
{\tt QUADRATIC\_FACET}$(X$, $Y$, $i)$
\item{} {\tt enddo}
\item{} Identify and store all nonmonotone intervals in a {\tt queue}.
\item{} {\tt do} $i = 1, \ldots n-1$
\item{} \codent {\tt if not IS\_MONOTONE}$(X_i$, $X_{i+1}$, $Q)$ {\tt then}
\item{} \codent\codent Add interval $\bigl(X_i$, $X_{i+1}\bigr)$ to
{\tt queue}.
\item{} \codent {\tt endif}
\item{} {\tt enddo}
\item{} {\tt do while} $\bigl($ {\tt queue} of nonmonotone intervals is
nonempty $\bigr)$
\itemitem{} Shrink (in magnitude) $DQ$ and $D^2Q$ that border nonmonotone
intervals.
\itemitem{} Identify and store all remaining nonmonotone intervals in
{\tt queue}.
\item{} {\tt enddo}
}
\vskip 5mm
%% ----------------------------------------------------------------------

Given the minimum magnitude curvature nature of the initial derivative
estimates, it is desirable to make the smallest necessary changes to
the initial interpolating spline $Q$ while enforcing monotonicity. In
practice a quasi-bisection search is used in place of solely shrinking
$DQ$ and $D^2Q$. This algorithm is outlined below. The goal is to
converge on the boundary of the monotone region in the $(\tau_1$,
$\alpha$, $\beta$, $\gamma)$ space.

%% ===================================================================
%%              Algorithm 4: Quasi-bisection search
\vskip 5mm
{\parindent 0mm
{\bf Algorithm 4:} {\tt QUASI-BISECTION}$\bigl(x_0, x_1, f \bigr)$

where $x_0$, $x_1 \in {\bbb R}$, $x_0 < x_1$, and $f$ is an order six
polynomial that is nonmonotone on the interval $[x_0$, $x_1]$. Defines
a stepping procedure for function derivative values that ensures $f$
can be made monotone in a fixed number of steps given a relative
precision $e \in {\bbb R}$.

}
{\parindent=6mm
\item{} Set a starting {\tt step\_size} and save the initial value of $f$.
\item{} $\hat f := f$
\item{} {\tt step\_size} $:= 1/2$
\item{} {\tt shrinking} $:=$ {\tt TRUE}
\item{} {\tt do while } $\big( ($ {\tt step\_size} $ > e)$ {\tt or not
  IS\_MONOTONE}$(x_1$, $x_2$, $f)$ $\big)$
\item{} \codent {\tt if shrinking then step\_size} $:=$ {\tt step\_size} $/ 2$

}
\vskip 5mm
%% ----------------------------------------------------------------------


As long as a step size schedule is
set that allows the value zero to be obtained in a fixed number of
computations, this has no effect on computational complexity. Notably,
since {\tt IS\_MONOTONE} handles both nondecreasing and nonincreasing
simultaneously by taking into account the sign of $v$, Algorithm 3
produces $Q(x)$ that is monotone increasing (decreasing) over exactly
the same intervals that the data $(X_i$, $Y_i)$ is monotone increasing
(decreasing).

