
\heading{2. MONOTONE QUINTIC INTERPOLATION}

In order to construct a monotone quintic interpolating spline, two
primary problems must be solved. First, reasonable derivative values
at data points need to be estimated. Second, the estimated derivative
values need to be modified to enforce monotonicity on all polynomial
pieces.

Fritsch and Carlson [1980] originally proposed the use of central differences
to estimate derivatives, however this often leads to extra and unnecessary
{\it wiggles} in the spline when used to approximate second derivatives.
In an attempt to capture the local shape of the data, this package uses a
facet model from image processing [Haralick and Watson 1981] to estimate
first and second derivatives at breakpoints. Rather than picking a local
linear or quadratic fit with minimal residual, this work uses a quadratic
facet model that selects the local quadratic interpolant with minimum
magnitude curvature.

%% ===================================================================
%%                   Algorithm 1: QUADRATIC_FACET
\vskip 5mm
{\parindent 0mm
{\bf Algorithm 1:} {
\tt QUADRATIC\_FACET}$\bigl(X(1{:}n)$, $Y(1{:}n)$, $i \bigr)$

where $X_j$, $Y_j$ $\in \bbb{R}$ for $j = 1$, $\ldots$, $n$, and $1
\le i \le n$. Returns the slope and curvature at $X_i$ of the local
quadratic interpolant with minimum magnitude curvature.

}
{\parindent=3mm
%% -------------------------------------------------------------------
\item{} {\tt if} $\bigl((Y_i \approx Y_{i-1})$ {\tt or} $(Y_i \approx
  Y_{i+1})\bigr)$ {\tt then; return $(0,0)$}
\item{} {\tt else if} $\bigl((Y_{i+1} - Y_i)(Y_i - Y_{i-1}) < 0\bigr)$
{\tt then}
\itemitem{} The point $(X_i$, $Y_i)$ is an extreme point. The
quadratic with minimum magnitude
curvature that has slope zero at $X_i$ will be the facet chosen.
\itemitem{} $f_1\:\hbox{interpolant to }(X_{i-1},Y_{i-1})$, $(X_i,Y_i)$,
  and $Df_1(X_i) = 0$.
\itemitem{} $f_2\:\hbox{interpolant to }(X_i,Y_i)$, $(X_{i+1},Y_{i+1})$,
  and $Df_2(X_i) = 0$.
\itemitem{} {\tt if} $\bigl(|D^2f_1| \leq |D^2f_2|\bigr)$ {\tt then;
  return} $\bigl(Df_1$, $D^2f_1\bigr)$
\itemitem{} {\tt else;} \hskip 34.25mm {\tt return} $\bigl(Df_2$,
$D^2f_2\bigr)$
\itemitem{} {\tt endif}
\item{} {\tt else}
\itemitem{} {The point $(X_i$, $Y_i)$ is in a monotone segment of
data. In the following, it is possible that $f_1$, $f_2$, or $f_3$ does
not exist because $i \in \{1, 2, n-1, n\}$. In those cases, the minimum
magnitude curvature among existing quadratics is chosen.}
\itemitem{} $f_1\:\hbox{interpolant to }(X_{i-2},Y_{i-2})$,
  $(X_{i-1},Y_{i-1})$, and $(X_i,Y_i)$.
\itemitem{} $f_2\:\hbox{interpolant to }(X_{i-1},Y_{i-1})$,
  $(X_i,Y_i)$, and $(X_{i+1},Y_{i+1})$.
\itemitem{} $f_3\:\hbox{interpolant to }(X_i,Y_i)$,
  $(X_{i+1},Y_{i+1})$, and $(X_{i+2},Y_{i+2})$.
\itemitem{} {\tt if} \hskip 9mm $\bigl(|D^2f_1| = \min\bigl\{ |D^2f_1|,
 |D^2f_2|, |D^2f_3|\bigr\} \bigr)$ {\tt then; return}
 $\bigl(Df_1$, $D^2f_1\bigr)$
\itemitem{} {\tt else if} $\bigl(|D^2f_2| = \min\bigl\{ |D^2f_1|,
 |D^2f_2|, |D^2f_3|\bigr\} \bigr)$ {\tt then; return}
 $\bigl(Df_2$, $D^2f_2\bigr)$
\itemitem{} {\tt else;} \codent {\tt return} $\bigl(Df_3$, $D^2f_3\bigr)$
\item{} \codent {\tt endif}
\item{} {\tt endif}
}
\vskip 5mm
%% ----------------------------------------------------------------------

The estimated derivative values by the quadratic facet model are not
guaranteed to produce monotone quintic polynomial segments. Ulrich and
Watson [1994] established tight constraints on the monotonicity of a
quintic polynomial piece, while deferring to He{\ss} and Schmidt
[1994] for a relevant simplified case. The following algorithm
implements a sharp check for monotonicity by considering the
nondecreasing case. The nonincreasing case is handled similarly.

%% ===================================================================
%%                    Algorithm 2: IS_MONOTONE
\vskip 5mm
{\parindent 0mm
{\bf Algorithm 2:} {\tt IS\_MONOTONE}$\bigl(x_0, x_1, f \bigr)$

where $x_0$, $x_1 \in {\bbb R}$, $x_0 < x_1$, and $f$ is an order six
polynomial defined by $f(x_0)$, $Df(x_0)$, $D^2f(x_0)$, $f(x_1)$,
$Df(x_1)$, $D^2f(x_1)$. Returns {\tt TRUE} if $f$ is monotone
increasing on $[x_0,x_1]$.

}
{\parindent=6mm
%% -------------------------------------------------------------------
\item{1.} {\tt if} $\bigl(f(x_0) \approx f(x_1)\bigr)$ {\tt then}
\item{2.} \codent {\tt return} $\bigl( 0 = Df(x_0) = Df(x_1)
  = D^2f(x_0) = D^2f(x_1) \bigr)$
\item{3.} {\tt endif}
\item{4.} {\tt if} $\bigl(Df(x_0) < 0$ {\tt or} $Df(x_1) < 0\bigr)$ {\tt
  then; return FALSE; endif}
\item{5.} $w \: x_1 - x_0$
\item{6.} $v \: f(x_1) - f(x_0)$

\item{} {The necessity of Steps 2 and 4 follows directly from
  the fact that $f$ is $C^2$. The following Steps 7--13 coincide with
  a simplified condition for quintic monotonicity that reduces to one
  of cubic positivity studied by Schmidt and He{\ss} [1988]. Given
  $\alpha$, $\beta$, $\gamma$, and $\delta$ as defined by Schmidt and
  He{\ss}, monotonicity results when $\alpha \geq 0$, $\delta \geq 0$,
  $\beta \geq \alpha - 2 \sqrt{\alpha \delta}$, and $\gamma \geq
  \delta - 2 \sqrt{\alpha \delta}$.  Step 4 checked for $\delta < 0$,
  Step 8 checks $\alpha < 0$, Step 10 checks $\beta < \alpha - 2
  \sqrt{\alpha \delta}$, and Step 11 checks $\gamma < \delta - 2
  \sqrt{\alpha \delta}$. If none of the monotonicity conditions are
  violated, then the order six piece is monotone and Step 12
  concludes.}

\item{7.} {\tt if} $\bigl(Df(x_0) \approx 0$ {\tt or} $Df(x_1) \approx
0\bigr)$ {\tt then}
\item{8.} \codent {\tt if} $\bigl(D^2f(x_1)w > 4Df(x_1)$ {\tt then;
return FALSE; endif}
\item{9.} \codent $t \: 2 \sqrt{Df(x_0) (4Df(x_1) - D^2f(x_1) w) }$
\item{10.} \codent {\tt if} $\bigl(t + 3Df(x_0) + D^2f(x_0)w < 0 \bigr)$
  {\tt then; return FALSE; endif}
\item{11.} \codent {\tt if} $\bigl(60v - w\bigl(24Df(x_0) + 32Df(x_1) - 2t
  + w(3D^2f(x_0) - 5D^2f(x_1))\bigr) < 0\bigr)$
\item{}   \codent \codent {\tt then; return FALSE; endif}
\item{12.} \codent {\tt return TRUE}
\item{13.} {\tt endif}

\item{} {The following code considers the full quintic monotonicity
case studied by Ulrich and Watson [1994]. Given $\tau_1$, $\alpha$,
$\beta$, and $\gamma$ as defined by Ulrich and Watson, a quintic
piece is proven to be monotone if and only if
$\tau_1 > 0$, and $\alpha, \gamma > -(\beta+2)/2$ when $\beta \leq 6$,
and $\alpha, \gamma > -2 \sqrt{\beta-2}$ when $\beta > 6$.
Step 14 checks $\tau_1 \le 0$, Steps 19 and 20 determine monotonicity based
on $\alpha$, $\beta$, and $\gamma$.}

\item{14.} {\tt if} $\bigl( w\bigl(2\sqrt{Df(x_0)\,Df(x_1)} - 3(Df(x_0) +
  Df(x_1))\bigr) - 24v \leq 0 \bigr)$
\item{} \codent {\tt then; return FALSE; endif}
\item{15.} $t \: \bigl(Df(x_0)\, Df(x_1)\bigr)^{3/4}$
\item{16.} $\alpha \: (4 Df(x_1) - D^2f(x_1)w) \sqrt{Df(x_0)} / t$
\item{17.} $\gamma \: (4 Df(x_0) - D^2f(x_0)w) \sqrt{Df(x_1)} / t$
\item{18.} $\displaystyle \beta \: {60v/w + 3\bigl(w(D^2f(x_1) -
  D^2f(x_0)) - 8(Df(x_0) + Df(x_1))\bigr) \over 2 \sqrt{Df(x_0)\,Df(x_1)}}$
\item{19.} {\tt if} $(\beta \leq 6)$ {\tt then; return}
$\bigl( \min\{\alpha,\gamma\} > - (\beta + 2) / 2 \bigr)$
\item{20.} {\tt else;} \hskip 18mm {\tt return}
$\bigl( \min\{\alpha,\gamma\} > -2 \sqrt{\beta - 2}\,\bigr)$
\item{21.} {\tt endif}
}
\vskip 5mm
%% ----------------------------------------------------------------------

It is shown by Ulrich and Watson [1994] that when $0 = DQ(X_i) =
DQ(X_{i+1}) = D^2Q(X_i) = D^2Q(X_{i+1})$, the quintic polynomial
over $[X_i$, $X_{i+1}]$ is guaranteed to be monotone. Using this fact, the
following algorithm shrinks (in magnitude) initial derivative estimates
until a monotone spline is achieved and outlines the core routine in the
accompanying package.

%% ===================================================================
%%       Algorithm 3: MQSI - Monotone quintic spline interpolant
\vskip 3mm
{\parindent 0mm
{\bf Algorithm 3:} {\tt MQSI}$\bigl(X(1{:}n), Y(1{:}n) \bigr)$

where $(X_i,Y_i) \in \bbb{R}\times\bbb{R}$, $i = 1$, $\ldots$, $n$ are data
points. Returns monotone quintic spline interpolant $Q(x)$ such that
$Q(X_i) = Y_i$ and is monotone increasing (decreasing) on all
intervals that $Y_i$ is monotone increasing (decreasing).

}
{\parindent=6mm
\item{} Approximate first and second derivatives at $X_i$ with {\tt
  QUADRATIC\_FACET}.
\item{} {\tt do} $i = 1, \ldots n$
\item{} \codent $\bigl(D Q(X_i)$, $D^2 Q(X_i)\bigr)\:$
{\tt QUADRATIC\_FACET}$(X$, $Y$, $i)$
\item{} {\tt enddo}
\item{} Identify and store all intervals where $Q$ is nonmonotone in a {\tt queue}.
\item{} {\tt do} $i = 1, \ldots n-1$
\item{} \codent {\tt if not IS\_MONOTONE}$(X_i$, $X_{i+1}$, $Q)$ {\tt then}
\item{} \codent\codent Add interval $\bigl(X_i$, $X_{i+1}\bigr)$ to
{\tt queue}.
\item{} \codent {\tt endif}
\item{} {\tt enddo}
\item{} {\tt do while} $\bigl($ {\tt queue} of intervals is nonempty $\bigr)$
\itemitem{} Shrink (in magnitude) $DQ$ and $D^2Q$ that border intervals where $Q$ is nonmonotone.
\itemitem{} Identify and store all remaining intervals where $Q$ is nonmonotone in {\tt queue}.
\item{} {\tt enddo}
\item{} Construct and return a spline representation of $Q(x)$.
}
\vskip 3mm
%% ----------------------------------------------------------------------

Since {\tt IS\_MONOTONE} handles both nondecreasing and
nonincreasing simultaneously by taking into account the sign of $v$,
Algorithm 3 produces $Q(x)$ that is monotone increasing (decreasing)
over exactly the same intervals that the data $(X_i$, $Y_i)$ is
monotone increasing (decreasing).

Given the minimum magnitude curvature nature of the initial derivative
estimates, it is desirable to make the smallest necessary changes to
the initial interpolating spline $Q$ while enforcing monotonicity. In
practice a binary search for the boundary of monotonicity is used in
place of solely shrinking $DQ$ and $D^2Q$ at breakpoints adjoining
{\it active} intervals, or intervals for which $Q$ is nonmonotone at
least once during the search. The binary search considers a Boolean
function $B(s)$, for $0 \le s \le 1$, that is true if the order six
polynomial on $[x_i, x_{i+1}]$ matching derivatives $f(x_i)$, $s
Df(x_i)$, $s D^2f(x_i)$ at $x_i$, and derivatives $f(x_{i+1})$, $s
Df(x_{i+1})$, $s D^2f(x_{i+1})$ at $x_{i+1}$ is monotone, and false
otherwise. As is outlined in Algorithm 3, the binary search is only
applied at those breakpoints adjoining intervals for which $Q$ is
nonmonotone and hence $B(1)$ is false. It is further assumed that
there exists $0 \le s^* \le 1$ such that $B(s)$ is true for $0 \le s
\le s^*$ and false for $s > s^*$. Since the derivative conditions at
interior breakpoints are shared by intervals left and right of the
breakpoint, the binary search is performed at all breakpoints
simultaneously.  Specifically, the monotonicity of $Q$ is checked on
all active intervals in each step of the binary search to determine
the next derivative modification at each breakpoint. The goal of this
search is to converge on the boundary of the monotone region in the
$(\tau_1$, $\alpha$, $\beta$, $\gamma)$ space for all intervals. This
multiple-interval binary search allows the value zero to be obtained
for all derivative values in a fixed number of computations, hence has
no effect on computational complexity. This binary search algorithm is
outlined below.


%% ===================================================================
%%              Algorithm 4: Global binary search
\vskip 5mm {\parindent 0mm {\bf Algorithm 4:} {\tt
    MULTIPLE\_BINARY\_SEARCH}$\bigl(X(1{:}n), Y(1{:}n), Q \bigr)$

where $(X_i,Y_i) \in \bbb{R}\times\bbb{R}$, $i = 1$, $\ldots$, $n$ are
data points, and $Q(x)$ is a quintic spline interpolant such that
$Q(X_i) = Y_i$. Modifies derivative values of $Q$ at data points to
ensure {\tt IS\_MONOTONE} is true for all intervals defined by
adjacent data points, given a desired precision $\mu \in {\bbb R}$.

}
{\parindent=6mm
\item{} Initialize the step size $s$, make a copy of $Q$, and construct
  three necessary queues for proceeding with the multiple-interval binary search.
\item{} $s \: 1$
\item{} $\hat Q \: Q$
\item{} {\tt searching} $\:$ {\tt TRUE}
\item{} {\tt checking} $\:$ empty queue for holding left indices of {\it intervals}
\item{} {\tt growing} $\:$ empty queue for holding indices of {\it data points}
\item{} {\tt shrinking} $\:$ empty queue for holding indices of {\it data points}
\item{} {\tt do} $i = 1$, $n-1$
\itemitem{} {\tt if not IS\_MONOTONE}$\bigl( X_i$, $X_{i+1}$, $Q \bigr)$ {\tt then}
\itemitem{} \codent Add interval starting at $i$ to {\tt shrinking}.
\itemitem{} {\tt endif}
\item{} {\tt enddo}
\item{} {\tt do while} $\bigl(${\tt searching or shrinking} is nonempty$\bigr)$
\itemitem{} Compute the {\it step size} for this iteration of the search.
\itemitem{} {\tt if  searching  then;} $s \: \max\{\mu, s / 2\}$
\itemitem{} {\tt else;} \hskip 24mm $s \: 3s / 2$
\itemitem{} {\tt endif}
\itemitem{} {\tt if} $(s = \mu)$ {\tt then; searching} $\:$ {\tt FALSE; endif}
\itemitem{} Increase $DQ$ and $D^2Q$ at all data points in {\tt growing}
  that are strictly adjoining intervals for which $Q$ is monotone.
\itemitem{} {\tt do} $(i \in$ {\tt growing}$)$ {\tt and} $(i \not \in$ {\tt shrinking}$)$
\itemitem{} \codent $DQ(X_i) \: DQ(X_i) + s D\hat Q(X_i)$
\itemitem{} \codent $D^2Q(X_i) \: D^2Q(X_i) + s D^2\hat Q(X_i)$
\itemitem{} \codent Add intervals starting at $i-1$ and $i$ to {\tt checking}.
\itemitem{} {\tt enddo}
\itemitem{} Decrease $DQ$ and $D^2Q$ at all data points in {\tt shrinking} and
  ensure those data point indices are placed into {\tt growing}.
\itemitem{} {\tt do} $i \in$ {\tt shrinking}
\itemitem{} \codent Add $i$ to {\tt growing} if it is not already present.
\itemitem{} \codent $DQ(X_i) \: DQ(X_i) - s D\hat Q(X_i)$
\itemitem{} \codent $D^2Q(X_i) \: D^2Q(X_i) - s D^2\hat Q(X_i)$
\itemitem{} \codent Add intervals starting at $i-1$ and $i$ to {\tt checking}.
\itemitem{} {\tt enddo}
\itemitem{} {Empty {\tt shrinking} queue then check all intervals in
  {\tt checking} for monotonicity with {\tt IS\_MONOTONE}, placing
  data points adjacent to intervals for which $Q$ is nonmonotone into
  {\tt shrinking}.}
\itemitem{} {\tt do} $i \in$ {\tt checking}
\itemitem{} \codent {\tt if not IS\_MONOTONE}$\bigl( X_i$, $X_{i+1}$, $Q \bigr)$ {\tt then}
\itemitem{} \codent \codent Add $i$ and $i+1$ to {\tt shrinking}.
\itemitem{} \codent {\tt endif}
\itemitem{} {\tt enddo}
\item{} {\tt enddo }
}
\vskip 5mm
%% ----------------------------------------------------------------------

%% \itemitem{} Take search steps either modifying derivative values
%%   towards monotonicity (zero) or towards the original values over all
%%   intervals that are either nonmonotone or previously modified.


In the provided package $\mu = 2^{-26}$, which results in a guaranteed
$26$ search steps for all intervals that are initially nonmonotone. An
additional $43$ steps could be required to reduce a derivative to zero
with step size growth rate of $3/2$. This can only happen when $Q$
becomes nonmonotone on an interval for the first time while the step
size equals $\mu$, but for which the only viable solution is a
derivative value of zero. The maximum number of steps is due to the
fact that $\sum_{i=0}^{42} \mu (3/2)^i > 1$. In total the {\tt
  MULTIPLE\_BINARY\_SEARCH} search could require $69$ steps.
